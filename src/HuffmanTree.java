import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

public class HuffmanTree {
	int QueueSize=Frequency.getMapSize();
	PriorityQueue<Node> q = new PriorityQueue<Node>(QueueSize, new NodeComparator()); 
	static Map<Character,String> code=new HashMap<>();
	public HuffmanTree()
	{
		for (Map.Entry<Character,Integer> entry : Frequency.Frequencies.entrySet())
		{
			Node n = new Node();
			n.c=entry.getKey();
			n.frequency=entry.getValue();
			n.left=null;
			n.Right=null;
			q.add(n);
		}
	Node root=null;
	while (q.size() > 1) { 
		  
        // first min extract. 
        Node x = q.peek(); 
        q.poll(); 
        // second min extarct. 
        Node y = q.peek(); 
        q.poll(); 
        // new node f which is equal 
        Node f = new Node(); 
        // to the sum of the frequency of the two nodes 
        // assigning values to the f node. 
        f.frequency = x.frequency + y.frequency; 
        f.c = '-'; 
        // first extracted node as left child. 
        f.left = x; 
        // second extracted node as the right child. 
        f.Right = y; 
        // marking the f node as the root node. 
        root = f;
        // add this node to the priority-queue. 
        q.add(f); 
    } 

    // print the codes by traversing the tree 
    generateTree(root, ""); 
} 
	public static void generateTree(Node root, String s) 
    { 
  
        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code s generated by traversing the tree. 
        if (root.left == null && root.Right== null /*&& /*Character.isLetter(root.c)*/) { 
            // c is the character in the node 
            //System.out.println(root.c + ":" + s);
            code.put(root.c, s);
            return; 
        } 
        generateTree(root.left, s + "0"); 
        generateTree(root.Right, s + "1"); 
    } 	
}
